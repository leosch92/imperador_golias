//
// PEG para golang visando a compilação e interpretação de código
// fonte na linguagem IMP
//

{
    package main
}

Input <- _ cl: Clauses _ EOF {
    return cl, nil
}

Clauses <- variable:(Variable _ ';' _ )?  constant:(Constant _ ';' _ )? 
           init:(Initialization _ ';' )? procs:( _ Procedure )+ calls:( _ Call )* {
    return constructClauses(variable, constant, init, procs, calls), nil
}

Procedure <- "proc" __ id:Identifier '(' formals: Formals ')' _ blk: Block{
    return constructProcedure(id, formals, blk), nil
}

Formals <- first:Identifier rest:(',' _ Identifier )* {
    return constructFormals(first, rest), nil
} / "" {
    return nil, nil
}

Call <- "exec" __ id:Identifier '(' actuals: Actuals ')' {
    return constructCall(id, actuals), nil
}

Actuals <- first:Expression rest:( ',' _ Expression )* {
    return constructActuals(first, rest), nil
} / "" {
    return nil, nil
}

Variable <- "var" __ id:Identifier rest:( _ ',' _ Identifier )* {
    return constructClauseDeclaration(id, rest), nil
}

Constant <- "const" __ id:Identifier rest:( _ ',' _ Identifier )* {
    return constructClauseDeclaration(id, rest), nil
}

Initialization <- "init" __ sInit:SingleInit rest:( _ ',' _ SingleInit )* {
    return constructInitialization(sInit, rest), nil
}

SingleInit <- id: Identifier _ '=' _ expr: Expression {
    return constructSingleInit(id, expr), nil
}

Command <- While /
           If /
           Print / 
           Assignment /
           Call

Sequence <- first:Command rest:( _ ';' _ Command )+ {
    return constructSequence(first, rest), nil
}

Assignment <- id:Identifier _ ":=" _ expr:Expression {
    return constructAssignment(id, expr), nil
}

While <- "while" __ '(' _ boolExp:BoolExp _ ')' __ "do" _ body:Block {
    return constructWhile(boolExp, body), nil
}

If <- "if" _ '(' _ boolExp:BoolExp _ ')' _ ifBody:Block _ elseStatement:("else" _ Block)? {
    return constructIf(boolExp, ifBody, elseStatement), nil
}

Print <- "print" _ '(' _ exp:Expression _ ')' {
    return constructPrint(exp), nil
}

Block <- '{' _ decl:(DeclarationSequence _ ';' _ )? cmd: ( Sequence / Command )  _ '}' {
    return constructBlock(decl, cmd), nil
}

DeclarationSequence <- first: Declaration _ ';' _ rest:( DeclarationSequence / Declaration ) {
    return constructDeclarationSequence(first, rest), nil
} / Declaration

Declaration <- declOp:DeclOp __ initSeq:InitSeq {
    return constructDeclaration(declOp, initSeq), nil
}

InitSeq <- sInit:SingleInit rest:( _ ',' _ SingleInit )* {
    return constructInitialization(sInit, rest), nil
}

DeclOp <- ("var" / "const") {
    return string(c.text), nil
}

Expression <- ArithExpr /
              BoolExp

ArithExpr <- first:Term rest:( _ AddOp _ Term )* {
    return constructArithExpr(first, rest), nil
}

Term <- first:Factor rest:( _ MulOp _ Factor )* {
    return constructArithExpr(first, rest), nil
}

Factor <- '(' expr:ArithExpr ')' {
    return expr, nil
} / integer:Integer {
    return integer, nil
} / id: Identifier {
    return id, nil
}

AddOp <- ('+' / '-' ) {
    return string(c.text), nil
}

MulOp <- ( '*' / '/' ) {
    return string(c.text), nil
}

BoolExp <- keyword: KeywordBoolExp {
    return constructKeywordBoolExp(keyword), nil
}
/ unBoolOp: UnaryBoolOp boolExp: BoolExp {
    return constructUnaryBoolExp(unBoolOp, boolExp), nil
}
/ id1: Identifier _ binBoolOp: BinaryBoolOp _ id2: Identifier {
    return constructBinaryLogicExp(binBoolOp, id1, id2), nil
}
/ id1: Identifier _ binBoolOp: BinaryBoolOp _ id2:ArithExpr {
    return constructBinaryArithExp(binBoolOp, id1, id2), nil
}

KeywordBoolExp <- ("true" / "false") {
    return string(c.text), nil
}

UnaryBoolOp <- '~'{
    return string(c.text), nil
}

BinaryBoolOp <- ( "==" / "<=" / ">=" / "<" / ">" / "/\\" / "\\/") {
    return string(c.text), nil
}

Identifier <- [a-zA-Z][0-9a-zA-Z]*{
    return string(c.text), nil
}

Integer <- '-'? [0-9]+ {
    return string(c.text), nil
}

_ "whitespace" <- [ \n\t\r]*
__ "obligatory_whitespace" <- [ \n\t\r]+

EOF <- !.