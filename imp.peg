{
// Command calculator is a small PEG-generated parser that computes
// simple math using integers.
//
// Example usage: $ calculator "3 + (2 - 5 * 12)"
//
// Inspired by pegjs arithmetic example:
// https://github.com/pegjs/pegjs/blob/master/examples/arithmetics.pegjs
//
package main

import "reflect"

var toBPLC = map[string]string{
	"+": "add",
    "-": "sub",
    "*": "mul",
    "/": "div",
}

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

func eval(first, rest interface{}) Tree {
    stringType := reflect.TypeOf("string teste")
    var t Tree

    if (reflect.TypeOf(first) == stringType){
        t = Tree{Left: nil, Value: first.(string), Right: nil}
    } else {
        t = first.(Tree)
    }
    
    restSl := toIfaceSlice(rest)

    for _, v := range restSl {
        restExpr := toIfaceSlice(v)
        var rightTree, leftTree Tree

        // Se recebe string da interface, constroi árvore nova, senão pega árvore já construída
        // do retorno do eval de um Factor 
        if (reflect.TypeOf(restExpr[3]) == stringType){
            r := restExpr[3].(string)
            rightTree = Tree{Left: nil, Value: r, Right: nil}
        } else {
            rightTree = restExpr[3].(Tree)
        }

        leftTree = t
        op := toBPLC[restExpr[1].(string)]
        t = Tree{Left: &leftTree, Value: op, Right: &rightTree}
    }
    return t
}


}

Input <- cmd:Command EOF {
    return cmd, nil
} / Teste

// ATENÇÃO!!! Regra criada especialmente para testes
// Qualquer programa que você quiser testar é só incluir as regras que você deseja
// Exemplo: quero testar "5==5", colocar então a regra associada BoolExp no Teste
// Como BoolExp é uma expressão booleana, ele vai conseguir parsear um programa que contenha
// uma expressão booleana sozinha, graças a essa regra de teste
Teste <- BoolExp { 
    return string(c.text), nil
}

Command <- Identifier _ ":=" _ Expression {
    return string(c.text), nil
} / While

While <- "while" __ '(' BoolExp ')' __ "do" _ Block{
    return string(c.text), nil
}

Block <- '{' _ Command _ '}'

Expression <- ArithExpr /
              Identifier /
              Identifier AddOp Identifier /
              Identifier MulOp Identifier /
              BoolExp

ArithExpr <- _ first:Term rest:( _ AddOp _ Term )* _ {
    return eval(first, rest), nil
}

Term <- first:Factor rest:( _ MulOp _ Factor )* {
    return eval(first, rest), nil
}

Factor <- '(' expr:Expr ')' {
    return expr, nil
} / integer:Integer {
    return integer, nil
}

AddOp <- ('+' / '-' ) {
    return string(c.text), nil
}

MulOp <- ( '*' / '/' ) {
    return string(c.text), nil
}

Integer <- '-'? [0-9]+ {
    return string(c.text), nil
}

Identifier <- [a-zA-Z][0-9a-zA-Z]*

BoolExp <- UnaryBoolOp Identifier /
           Identifier __ BinaryBoolOp __ Identifier /
           Identifier __ BinaryBoolOp __ ArithExpr

UnaryBoolOp <- '~'

BinaryBoolOp <- ("==" / "<=" / ">=" / "<" / ">")

_ "whitespace" <- [ \n\t\r]*
__ "obligatory_whitespace" <- [ \n\t\r]+

EOF <- !.
