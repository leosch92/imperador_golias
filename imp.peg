
//
// PEG para golang visando a compilação e interpretação de código
// fonte na linguagem IMP
//

{
package main

import "reflect"

var toBPLC = map[string]string{
	"+": "add",
    "-": "sub",
    "*": "mul",
    "/": "div",
    "while": "while",
    "~": "neg",
    ">=": "ge",
    ">": "gt",
    "<=": "le",
    "<": "lt",
    "==": "eq",
    "/\\": "and",
    "\\/": "or",
}

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

func evalArithExpr(first, rest interface{}) *Tree {
    stringType := reflect.TypeOf("string teste")
    var t Tree

    if (reflect.TypeOf(first) == stringType){
        t = Tree{first.(string), initSons()}
    } else {
        t = *first.(*Tree)
    }
    
    restSl := toIfaceSlice(rest)

    for _, v := range restSl {
        restExpr := toIfaceSlice(v)
        operator := toBPLC[restExpr[1].(string)]
        auxTree := t
        t = Tree{operator, initSons()}
        
        t.Sons = append(t.Sons, &auxTree)
        
        // Se recebe string da interface, constroi árvore nova, senão pega árvore já construída
        // do retorno do eval de um Factor
        rightOp := restExpr[3]

        if (reflect.TypeOf(rightOp) == stringType){

            // Insere o operando da direita como novo filho
            t.Sons = append(t.Sons, &Tree{rightOp.(string), initSons()})

        } else {
            t.Sons = append(t.Sons, rightOp.(*Tree))
        }
        
        
    }
    return &t
}

func evalWhile(boolExp, body interface{}) *Tree {
    t := Tree{toBPLC["while"], initSons()}
    t.Sons = append(t.Sons, boolExp.(*Tree))
    t.Sons = append(t.Sons, body.(*Tree))
    return &t
}

func evalKeywordBoolExp(keyword interface{}) *Tree{
    return &Tree{keyword.(string), initSons()}
}

func evalUnaryBoolExp(unBoolOp, boolExp interface{}) *Tree{
    t := Tree{toBPLC[unBoolOp.(string)], initSons()}
    t.Sons = append(t.Sons, boolExp.(*Tree))
    return &t
}

func evalBinaryLogicExp(binBoolOp, id1, id2 interface{}) *Tree {
    t := Tree{toBPLC[binBoolOp.(string)], initSons()}
    t.Sons = append(t.Sons, &Tree{id1.(string), initSons()})
    t.Sons = append(t.Sons, &Tree{id2.(string), initSons()})
    return &t
}

func evalBinaryArithExp(binBoolOp, id1, id2 interface{}) *Tree {
    t := Tree{toBPLC[binBoolOp.(string)], initSons()}
    t.Sons = append(t.Sons, &Tree{id1.(string), initSons()})
    t.Sons = append(t.Sons, id2.(*Tree))
    return &t
}

}

Input <- cmd:Command EOF {
    return cmd, nil
} / Teste

// ATENÇÃO!!! Regra criada especialmente para testes
// Qualquer programa que você quiser testar é só incluir as regras que você deseja
// Exemplo: quero testar "5==5", colocar então ponha a regra associada BoolExp no Teste
// Como BoolExp é uma expressão booleana, ele vai conseguir parsear um programa que contenha
// uma expressão booleana sozinha, graças a essa regra de teste. Para adicionar novas regras
// basta incluir o caractere '/' para começar nova regra, como em casos abaixo
Teste <- ArithExpr

Command <- Identifier _ ":=" _ Expression {
    return string(c.text), nil
} / while:While {
    return while, nil
} / arithExpr: ArithExpr {
    return arithExpr, nil
}

While <- "while" __ '(' _ boolExp:BoolExp _ ')' __ "do" _ body:Block {
    return evalWhile(boolExp, body), nil
}


Block <- '{' _ cmd:Command _ '}' {
    return cmd, nil
}

Expression <- ArithExpr /
              Identifier /
              Identifier AddOp Identifier /
              Identifier MulOp Identifier /
              BoolExp

ArithExpr <- _ first:Term rest:( _ AddOp _ Term )* _ {
    return evalArithExpr(first, rest), nil
}

Term <- first:Factor rest:( _ MulOp _ Factor )* {
    return evalArithExpr(first, rest), nil
}

Factor <- '(' expr:ArithExpr ')' {
    return expr, nil
} / integer:Integer {
    return integer, nil
}

AddOp <- ('+' / '-' ) {
    return string(c.text), nil
}

MulOp <- ( '*' / '/' ) {
    return string(c.text), nil
}

Integer <- '-'? [0-9]+ {
    return string(c.text), nil
}

BoolExp <- keyword: KeywordBoolExp {
    return evalKeywordBoolExp(keyword), nil
} 
/ unBoolOp: UnaryBoolOp boolExp: BoolExp {
    return evalUnaryBoolExp(unBoolOp, boolExp), nil
}
/ id1: Identifier _ binBoolOp: BinaryBoolOp _ id2: Identifier {
    return evalBinaryLogicExp(binBoolOp, id1, id2), nil
} 
/ id1: Identifier _ binBoolOp: BinaryBoolOp _ id2:ArithExpr {
    return evalBinaryArithExp(binBoolOp, id1, id2), nil
}

KeywordBoolExp <- ("true" / "false") {
    return string(c.text), nil
}    

UnaryBoolOp <- '~'{
    return string(c.text), nil
}

BinaryBoolOp <- ( "==" / "<=" / ">=" / "<" / ">" / "/\\" / "\\/") {
    return string(c.text), nil
}

_ "whitespace" <- [ \n\t\r]*
__ "obligatory_whitespace" <- [ \n\t\r]+

Identifier <- [a-zA-Z][0-9a-zA-Z]*{
    return string(c.text), nil
}

EOF <- !.
