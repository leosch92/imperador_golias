{
// Command calculator is a small PEG-generated parser that computes
// simple math using integers.
//
// Example usage: $ calculator "3 + (2 - 5 * 12)"
//
// Inspired by pegjs arithmetic example:
// https://github.com/pegjs/pegjs/blob/master/examples/arithmetics.pegjs
//
package main

import "reflect"

var toBPLC = map[string]string{
	"+": "add",
    "-": "sub",
    "*": "mul",
    "/": "div",
}

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

func eval(first, rest interface{}) Tree {
    stringType := reflect.TypeOf("string teste")
    var t Tree

    if (reflect.TypeOf(first) == stringType){
        t = Tree{Left: nil, Value: first.(string), Right: nil}
    } else {
        t = first.(Tree)
    }
    
    restSl := toIfaceSlice(rest)

    for _, v := range restSl {
        restExpr := toIfaceSlice(v)
        var rightTree, leftTree Tree

        // Se recebe string da interface, constroi árvore nova, senão pega árvore já construída
        // do retorno do eval de um Factor 
        if (reflect.TypeOf(restExpr[3]) == stringType){
            r := restExpr[3].(string)
            rightTree = Tree{Left: nil, Value: r, Right: nil}
        } else {
            rightTree = restExpr[3].(Tree)
        }

        leftTree = t
        op := toBPLC[restExpr[1].(string)]
        t = Tree{Left: &leftTree, Value: op, Right: &rightTree}
    }
    return t
}


}

Input <- expr:Expr EOF {
    return expr, nil
}

Expr <- _ first:Term rest:( _ AddOp _ Term )* _ {
    return eval(first, rest), nil
}

Term <- first:Factor rest:( _ MulOp _ Factor )* {
    return eval(first, rest), nil
}

Factor <- '(' expr:Expr ')' {
    return expr, nil
} / integer:Integer {
    return integer, nil
}

AddOp <- ('+' / '-' ) {
    return string(c.text), nil
}

MulOp <- ( '*' / '/' ) {
    return string(c.text), nil
}

Integer <- '-'? [0-9]+ {
    return string(c.text), nil
}

_ "whitespace" <- [ \n\t\r]*

EOF <- !.
