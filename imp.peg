
//
// PEG para golang visando a compilação e interpretação de código
// fonte na linguagem IMP
//

{
package main

import "reflect"

var toBPLC = map[string]string{
	"+": "add",
    "-": "sub",
    "*": "mul",
    "/": "div",
    "while": "while",
}

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

func evalArithExpr(first, rest interface{}) Tree {
    stringType := reflect.TypeOf("string teste")
    var t Tree

    if (reflect.TypeOf(first) == stringType){
        t = Tree{first.(string), initSons()}
    } else {
        t = first.(Tree)
    }
    
    restSl := toIfaceSlice(rest)

    for _, v := range restSl {
        restExpr := toIfaceSlice(v)
        op := toBPLC[restExpr[1].(string)]
        firstOperand := t.Value
        t = Tree{op, initSons()}
        
        // Se recebe string da interface, constroi árvore nova, senão pega árvore já construída
        // do retorno do eval de um Factor

        if (reflect.TypeOf(restExpr[3]) == stringType){
            t.insert(restExpr[3].(string), 1) // Insere o operando da direita no segundo filho
        } else {
            secondTree := restExpr[3].(Tree)
            t.Sons[1] = &secondTree
        }
        
        t.insert(firstOperand, 0)
    }
    return t
}

}

Input <- cmd:Command EOF {
    return cmd, nil
} / Teste

// ATENÇÃO!!! Regra criada especialmente para testes
// Qualquer programa que você quiser testar é só incluir as regras que você deseja
// Exemplo: quero testar "5==5", colocar então ponha a regra associada BoolExp no Teste
// Como BoolExp é uma expressão booleana, ele vai conseguir parsear um programa que contenha
// uma expressão booleana sozinha, graças a essa regra de teste. Para adicionar novas regras
// basta incluir o caractere '/' para começar nova regra, como em casos abaixo
Teste <- ArithExpr

Command <- Identifier _ ":=" _ Expression {
    return string(c.text), nil
} / While

While <- while:"while" __ '(' _ boolExp:BoolExp _ ')' __ "do" _ Block

Block <- '{' _ Command _ '}'

Expression <- ArithExpr /
              Identifier /
              Identifier AddOp Identifier /
              Identifier MulOp Identifier /
              BoolExp

ArithExpr <- _ first:Term rest:( _ AddOp _ Term )* _ {
    return evalArithExpr(first, rest), nil
}

Term <- first:Factor rest:( _ MulOp _ Factor )* {
    return evalArithExpr(first, rest), nil
}

Factor <- '(' expr:ArithExpr ')' {
    return expr, nil
} / integer:Integer {
    return integer, nil
}

AddOp <- ('+' / '-' ) {
    return string(c.text), nil
}

MulOp <- ( '*' / '/' ) {
    return string(c.text), nil
}

Integer <- '-'? [0-9]+ {
    return string(c.text), nil
}

Identifier <- [a-zA-Z][0-9a-zA-Z]*

BoolExp <- UnaryBoolOp Identifier /
           Identifier __ BinaryBoolOp __ Identifier /
           Identifier __ BinaryBoolOp __ ArithExpr / 
           "true" /
           "false"

UnaryBoolOp <- '~'

BinaryBoolOp <- ("==" / "<=" / ">=" / "<" / ">")

_ "whitespace" <- [ \n\t\r]*
__ "obligatory_whitespace" <- [ \n\t\r]+

EOF <- !.
